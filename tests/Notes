In the most basic terms, skipping over lots of gory details, this is the basics of how the framework operates

A Controller's dispatch method is called
	* Calls Controller's initialize method
	* determines a module/action to use
	* Forwards to module/action

Controller's initialize method is called
	* Passes a reference of itself to a request for an instance of Context [Context::getInstance($this)]
	* Requests references to various factory objects from the context

Context's getInstance is called
	* saves reference to calling controller (only a controller should ask the context for an instance directly)
	* loads configured factory objects (db, user, storage, etc)
	* returns singleton instance of self

Controller's forward is called
	* instantiate's an action
	* creates an ActionEntry of action on the ActionStack
	* loads and executes filters

Execute Filter
	* loads and executes validators
	* Executes the action
	* determines view to use
	* executes view's render method
	* Note: if View::RENDER_VAR is the render method set on the controller, 
		the rendered view is saved in the ActionEntry and ActionEntry->getPresentation() 
		can be used to retrieve it.


Ok, so now that you understand the basics.. :) 
If the piece of code you are testing needs to interact with other pieces of the system,
you can mock the interactions through the MockContext (which itself is not a true mock object)
as an example, the MockContext sets up mock factory objects for DatabaseManager, User, etc. If
the piece of code you are testing needs to interact with the db. You can configure the mock DatabaseManager
to return a mock db of your choosing, and configure that mock db with the behavior the real db should
exert. Then you can not only verify the code you're testing reacts as it should, it also INTERACTS as it should.

Let me elaborate with an example. (FIXME, write a better example)

public function testSaveRecord()
{
	// Create a mock database object
	Mock::generate('MySQLDatabase');
	$db = new MockMySQLDatabase($this); // need to pass our test to the mock's constructor
	
	// MySQLDatabase is a simple wrapper around the native MySQL driver
	// Setup some behavior on our mock db
	// if we call $db->mysql_fetch_asoc("SELECT * FROM user WHERE id = '1'"); we will be given the $res array as a result.
	$res = array('id' => 1, 'name' => 'John Doe', 'email' => 'jdoe@someplace.com');
	$q = "SELECT * FROM user WHERE id = '1'"'
	
	$db->setReturn('mysql_fetch_assoc', $res, array($q)); 
	$db->expectOnce('mysql_fetch_assoc', array($q));
	
	// when we ask the dbmgr for the db handle, we'll get a reference to our mock db
	$this->_context->getDatabaseManager->setReturnReference('getDatabase', $db); 
	
	// we expect that we'll ask for the db at least once
	$this->_context->getDatabaseManager->expectAtLeastOnce('getDatabase');

	$sompn = new Sompn();
	$this->assertTrue($sompn->thatShouldReturnTrue());
	// check our expected behavior, too
	$db->tally(); 
	$this->_context->getDatabaseManager->tally();

}







